<!-- 
 https://buy.sssaham.com?kode=KODE&mode=TYPE
 Version: 1.0.0
    TYPE: swing | intraday
-->
<!DOCTYPE html>
<html lang="id">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#ffffff" />

    <title>SSSAHAM - Detail Emiten</title>

    <!-- (opsional) samain dengan index.html -->
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="apple-touch-icon" sizes="180x180" href="../img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../img/favicon-16x16.png">

    <!-- Bootstrap & Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet" />
    <link href="component.css" rel="stylesheet" />

    <style>
        .card-swing {
            border-radius: 12px;
            border: none;
        }

        .card-swing-header {
            background: #f9fafb;
            border-bottom: 1px solid rgba(148, 163, 184, 0.4);
            border-radius: 12px 12px 0 0;
            padding: 0.5rem 0.75rem;
        }

        .quadrant-badge {
            min-width: 28px;
            text-align: center;
            border-radius: 999px;
            font-size: 0.8rem;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #6b7280;
        }

        .stat-value {
            font-size: 1rem;
            font-weight: 600;
        }

        #timeseries-table td,
        #timeseries-table th {
            vertical-align: middle;
            font-size: 0.9rem;
            text-align: center;
        }


        @media (max-width: 576px) {
            .page-title {
                font-size: 1rem;
            }
        }
    </style>
</head>

<body>
    <!-- NAVBAR -->
    <nav class="navbar sticky-top border-bottom">
        <div class="container d-flex align-items-center" style="max-width: 1200px;">
            <a href="index.html" class="d-flex align-items-center text-decoration-none me-2">
                <i class="fa-solid fa-chevron-left"></i>
                <span class="small d-none">Kembali</span>
            </a>
            <div class="flex-grow-1 text-center">
                <span class="nav-title" id="nav-kode">Detail Emiten</span>
            </div>
            <div style="width:72px;" class="text-end">
                <i class="fa-solid fa-magnifying-glass" onclick="toggleSearch()"></i>
            </div>
        </div>
    </nav>

    <div id="app" class="container my-3">
        <!-- NAVIGATION TABS -->
        <ul class="nav nav-tabs mb-3" role="tablist">
            <li class="nav-item" role="presentation">
                <span class="nav-link active" id="intraday-tab">Intraday</span>
            </li>
            <li class="nav-item" role="presentation">
                <a class="nav-link" id="fundflow-link" href="#">Fund Flow</a>
            </li>
            <li class="nav-item" role="presentation">
                <a class="nav-link" id="audit-link" href="#">Audit Trail</a>
            </li>
        </ul>

        <!-- HEADER EMITEN -->
        <div class="mb-3 d-none">
            <div class="d-flex justify-content-between align-items-center">
                <div>
                    <div class="page-title" id="title-kode">-</div>
                </div>
            </div>
        </div>

        <!-- SNAPSHOT STATS -->
        <div class="row g-3 mb-1 text-center">
            <div class="col-6 col-md-3">
                <div class="stat-label">Close</div>
                <div class="stat-value" id="stat-close">-</div>
            </div>
            <div class="col-6 col-md-3">
                <div class="stat-label">Range (Lâ€“H)</div>
                <div class="stat-value" id="stat-range">-</div>
            </div>
            <div class="col-6 col-md-3">
                <div class="stat-label">Vol / Net</div>
                <div class="stat-value" id="stat-vol-net">-</div>
            </div>
            <div class="col-6 col-md-3">
                <div class="stat-label">%Haka / Mom%</div>
                <div class="stat-value" id="stat-haka-mom">/</div>
            </div>
        </div>

        <!-- FALLBACK ALERT -->
        <div id="fallback-alert" class="d-none alert alert-light border-warning shadow-sm py-2 px-3 mb-3"
            style="font-size: 0.85rem;">
            <i class="fa-solid fa-lightbulb text-warning me-2"></i>
            <span class="text-dark">Menampilkan data cadangan (optimasi). Perbaikan data utama sedang berlangsung di
                background.</span>
        </div>

        <!-- REPAIR STATUS (Dynamic) -->
        <div id="repair-container" class="d-none mb-3">
            <div class="card card-swing border-primary">
                <div class="card-body text-center py-4">
                    <div class="spinner-border text-primary mb-3" role="status"></div>
                    <h5 class="fw-bold text-dark" id="repair-title">Update Data...</h5>
                    <p class="text-muted small mb-2" id="repair-status-text">Mendeteksi data rusak, memulai perbaikan
                        otomatis.</p>
                    <div class="progress mx-auto" style="height: 10px; max-width: 400px; border-radius: 5px;">
                        <div id="repair-progress-bar"
                            class="progress-bar progress-bar-striped progress-bar-animated bg-primary"
                            role="progressbar" style="width: 5%"></div>
                    </div>
                    <p class="text-primary fw-bold mt-2 small" id="repair-pct-text">5%</p>
                </div>
            </div>
        </div>

        <!-- FOOTPRINT CHART -->
        <div id="chart-container" class="card card-swing mb-4">
            <div class="card-body" style="height:55vh;">
                <canvas id="footprintChart"></canvas>
            </div>
        </div>

        <!-- RAW DETAIL (OPTIONAL) -->
        <div class="card card-swing mb-4 d-none">
            <div class="card-swing-header">
                <div class="small text-muted">Detail Snapshot</div>
            </div>
            <div class="card-body">
                <pre id="raw-json" class="mb-0"></pre>
            </div>
        </div>
        <!-- TIME SERIES TABLE -->
        <div id="table-container" class="card card-swing mb-4">
            <div class="card-body p-0">
                <div class="table-responsive">
                    <table class="table table-sm mb-0" id="timeseries-table">
                        <thead class="table-light">
                            <tr>
                                <th class="text-center">Date</th>
                                <th class="text-center">Time</th>
                                <th class="text-end">Harga</th>
                                <th class="text-end">Î” Harga</th>
                                <th class="text-end">Moment %</th>
                                <th class="text-end">Absorb</th>
                                <th class="text-end">CVD</th>
                                <th class="text-end">Value (cum)</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- SCRIPTS -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
    <!-- Add financial chart support -->
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.0/dist/chartjs-chart-financial.min.js"></script>
    <script src="component.js"></script>

    <script>
        Chart.register(ChartDataLabels);

        const isLocal = false; // Force remote for now
        const API_BASE = isLocal
            ? "http://127.0.0.1:8787"
            : "https://api-saham.mkemalw.workers.dev";

        let footprintChart = null;

        // Garis silang 4 kuadran
        const quadrantLinesPlugin = {
            id: "quadrantLines",
            afterDraw(chart) {
                const { ctx, chartArea, scales } = chart;
                const xScale = scales.x;
                const yScale = scales.y;
                const xZero = xScale.getPixelForValue(0);
                const yZero = yScale.getPixelForValue(0);

                ctx.save();
                ctx.strokeStyle = "rgba(148,163,184,0.9)";
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 3]);

                ctx.beginPath();
                ctx.moveTo(xZero, chartArea.top);
                ctx.lineTo(xZero, chartArea.bottom);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(chartArea.left, yZero);
                ctx.lineTo(chartArea.right, yZero);
                ctx.stroke();

                ctx.restore();
            }
        };

        function formatNum(n) {
            if (n === null || n === undefined || isNaN(n)) return "-";
            return n.toLocaleString("id-ID");
        }

        function getKodeFromURL() {
            const params = new URLSearchParams(location.search);
            return params.get("kode") || "BBCA";
        }

        function getModeFromURL() {
            const params = new URLSearchParams(location.search);
            return params.get("mode") || "swing";
        }

        function updateQuadrantBadge(q) {
            const badge = document.getElementById("badge-quadrant");
            if (!badge) return; // â¬…ï¸ kalau belum ada badge di HTML, jangan bikin error

            badge.textContent = q ? `Q${q}` : "Q-";
            badge.className = "quadrant-badge";

            if (q === 1) badge.classList.add("bg-success", "text-white");
            else if (q === 2) badge.classList.add("bg-info", "text-dark");
            else if (q === 3) badge.classList.add("bg-danger", "text-white");
            else if (q === 4) badge.classList.add("bg-warning", "text-dark");
            else badge.classList.add("bg-secondary", "text-white");
        }


        // Header + angka snapshot
        function renderSnapshot(kode, mode, snapshot, state) {
            $("#nav-kode").text(kode);
            $("#title-kode").text(`${kode} Â· Swing Footprint`);
            $("#subtitle-mode").text(`Mode: ${mode}`);

            const { close, high, low, vol, net_vol, haka_pct, fluktuasi } = snapshot || {};

            $("#stat-close").text(formatNum(close));
            $("#stat-range").text(`${formatNum(low)} â€“ ${formatNum(high)}`);
            $("#stat-vol-net").text(`${formatNum(vol)} / ${formatNum(net_vol)}`);
            $("#stat-haka-mom").text(
                `${haka_pct != null ? Number(haka_pct).toFixed(0) : "-"}% / ${fluktuasi != null ? Number(fluktuasi).toFixed(2) : "-"}%`
            );

            updateQuadrantBadge(state?.quadrant);

            const rawCombined = {
                kode,
                mode,
                snapshot,
                state,
            };
            $("#raw-json").text(JSON.stringify(rawCombined, null, 2));
        }

        function renderFootprintTrailFromHistory(kode, snapshot, history, tableData) {
            const canvas = document.getElementById("footprintChart");
            if (!canvas) return;

            // Use tableData for base candlesticks (has all time points)
            // Use history for absorption bubbles (where actual footprint data exists - bv/av)
            const timeSeriesData = tableData || [];
            // Filter bubbles: only show where actual bid/ask volume exists
            const absorptionData = (history || []).filter(h => (h.bv > 0 || h.av > 0) && h.x > 0);

            // Debug logging
            console.log('[CHART] timeSeriesData:', timeSeriesData.length, 'rows', timeSeriesData.slice(0, 2));
            console.log('[CHART] absorptionData:', absorptionData.length, 'bubbles', absorptionData.slice(0, 2));

            if (!timeSeriesData.length && !absorptionData.length) {
                console.warn('[CHART] No data to render - both timeSeriesData and absorptionData are empty');
                if (footprintChart) {
                    footprintChart.destroy();
                    footprintChart = null;
                }
                return;
            }

            // Generate OHLC candles from tableData
            // For sparse data, each row becomes a candle with O=H=L=C = price
            const candleData = timeSeriesData.map(row => ({
                x: row.x,
                o: row.p,
                h: row.p,
                l: row.p,
                c: row.p
            }));

            // Price analysis for Y-scale
            const allPrices = timeSeriesData.map(r => r.p).filter(p => !isNaN(p) && p > 0);
            if (!allPrices.length) {
                if (footprintChart) {
                    footprintChart.destroy();
                    footprintChart = null;
                }
                return;
            }

            const minY = Math.min(...allPrices);
            const maxY = Math.max(...allPrices);
            const yRange = maxY - minY;
            const yPadding = yRange * 0.1 || 5;

            // ========================================
            // 1. AGGREGATE ABSORPTION PER 30 MINUTES
            // ========================================
            const bucket30min = new Map(); // key: timestamp_30min -> { bv, av, totalV, prices: Set }
            absorptionData.forEach(h => {
                const t30 = Math.floor(h.x / (30 * 60 * 1000)) * (30 * 60 * 1000);
                if (!bucket30min.has(t30)) {
                    bucket30min.set(t30, { t0: t30, bv: 0, av: 0, totalV: 0, prices: new Set(), timestamps: [] });
                }
                const b = bucket30min.get(t30);
                b.bv += (h.bv || 0);
                b.av += (h.av || 0);
                b.totalV += (h.v || 0);
                b.prices.add(h.p);
                b.timestamps.push(h.x); // Store timestamps for proper centering
            });

            // Convert to bubble points (only show significant bubbles)
            const aggregatedBubbles = [];
            const allVols30 = Array.from(bucket30min.values()).map(b => b.totalV);
            const maxVol30 = allVols30.length ? Math.max(...allVols30) : 1;

            bucket30min.forEach((b, t0) => {
                if (b.totalV < maxVol30 * 0.1) return; // Skip small bubbles (< 10% of max)

                const avgPrice = Array.from(b.prices).reduce((a, c) => a + c, 0) / b.prices.size;
                const side = b.bv >= b.av ? 'buy' : 'sell';
                const sizeNorm = b.totalV / maxVol30;
                const r = 8 + sizeNorm * 20; // Bigger bubbles for aggregated data

                // CORRECTED COLORS: 
                // Green = Buy absorption (buyers defending, price tends to go UP)
                // Red = Sell absorption (sellers defending, price tends to go DOWN)
                const alpha = 0.6;
                const bg = side === 'buy' ? `rgba(239,68,68,${alpha})` : `rgba(34,197,94,${alpha})`;
                const border = side === 'buy' ? `rgba(185,28,28,0.9)` : `rgba(21,128,61,0.9)`;

                // Position at center of actual timestamps in this bucket (not fixed +15min)
                const timestamps = b.timestamps || [t0];
                const centerTime = timestamps.length > 0
                    ? timestamps.reduce((a, c) => a + c, 0) / timestamps.length
                    : t0 + 15 * 60 * 1000;

                aggregatedBubbles.push({
                    x: centerTime,
                    y: avgPrice,
                    r,
                    bg,
                    border,
                    time: new Date(t0).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', timeZone: 'Asia/Jakarta' }),
                    v: b.totalV,
                    bv: b.bv,
                    av: b.av,
                    side: side
                });
            });

            // ========================================
            // 2. BUILD VOLUME PROFILE (Price Levels)
            // ========================================
            const volumeByPrice = new Map(); // price -> { bv, av, totalV }
            absorptionData.forEach(h => {
                if (!volumeByPrice.has(h.p)) {
                    volumeByPrice.set(h.p, { price: h.p, bv: 0, av: 0, totalV: 0 });
                }
                const vp = volumeByPrice.get(h.p);
                vp.bv += (h.bv || 0);
                vp.av += (h.av || 0);
                vp.totalV += (h.v || 0);
            });

            // Sort by volume and get top levels
            const volumeProfileData = Array.from(volumeByPrice.values())
                .sort((a, b) => b.totalV - a.totalV)
                .slice(0, 10); // Top 10 price levels

            const maxVolProfile = volumeProfileData.length ? Math.max(...volumeProfileData.map(v => v.totalV)) : 1;

            // ========================================
            // 3. CREATE LINE CHART DATA
            // ========================================
            const lineChartData = timeSeriesData.map(row => ({
                x: row.x,
                y: row.p
            }));

            // Calculate time range for volume profile bar width
            const timeMin = lineChartData.length > 0 ? lineChartData[0].x : 0;
            const timeMax = lineChartData.length > 0 ? lineChartData[lineChartData.length - 1].x : 1;
            const timeRange = timeMax - timeMin || 1;

            // Create horizontal bar data for volume profile (rendered as annotations later)
            const volumeProfileBars = volumeProfileData.map(vp => ({
                x: timeMin,
                y: vp.price,
                barWidth: (vp.totalV / maxVolProfile) * timeRange * 0.2, // 20% of chart width max
                totalV: vp.totalV,
                bv: vp.bv,
                av: vp.av,
                side: vp.bv >= vp.av ? 'buy' : 'sell'
            }));

            // ========================================
            // 4. BUILD DATASETS
            // ========================================
            const datasets = [
                {
                    label: "Price",
                    type: 'line',
                    data: lineChartData,
                    borderColor: '#6366f1',
                    backgroundColor: 'rgba(99, 102, 241, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.1,
                    pointRadius: 0, // Remove point dots - pure line
                    order: 2
                }
            ];

            // ========================================
            // 5. ADD CUMULATIVE VOLUME DELTA (CVD) LINE
            // ========================================
            let runningCVD = 0;
            const cvdData = timeSeriesData.map(row => {
                runningCVD += (row.a || 0); // 'a' is delta from tableData
                return { x: row.x, y: runningCVD };
            });

            // Store CVD data for table rendering
            window.cvdDataForTable = cvdData;

            if (cvdData.length > 1) {
                datasets.push({
                    label: "CVD",
                    type: 'line',
                    data: cvdData,
                    borderColor: '#f97316', // Orange
                    borderWidth: 2,
                    borderDash: [5, 5], // Dashed line
                    fill: false,
                    tension: 0.1,
                    pointRadius: 0,
                    order: 3,
                    yAxisID: 'y1' // Use secondary right axis
                });
            }

            // Add aggregated absorption bubbles
            if (aggregatedBubbles.length > 0) {
                datasets.unshift({
                    label: "Absorption (30min)",
                    type: 'bubble',
                    data: aggregatedBubbles,
                    backgroundColor: aggregatedBubbles.map(p => p.bg),
                    borderWidth: 0, // No border
                    order: 1
                });
            }

            // Add Volume Profile bars as horizontal bars (using line segments)
            if (volumeProfileBars.length > 0) {
                const vpDataset = {
                    label: "Volume Profile",
                    type: 'line',
                    data: [],
                    borderWidth: 0,
                    pointRadius: 0,
                    showLine: false,
                    order: 3
                };

                // Create horizontal bar for each price level
                volumeProfileBars.forEach((vp, idx) => {
                    const barColor = vp.side === 'buy' ? 'rgba(59, 130, 246, 0.6)' : 'rgba(239, 68, 68, 0.4)';
                    datasets.push({
                        label: idx === 0 ? "VP Level" : "",
                        type: 'line',
                        data: [
                            { x: timeMin, y: vp.y },
                            { x: timeMin + vp.barWidth, y: vp.y }
                        ],
                        borderColor: barColor,
                        borderWidth: 8,
                        pointRadius: 0,
                        showLine: true,
                        tension: 0,
                        order: 4
                    });
                });
            }

            const data = { datasets };

            const options = {
                responsive: true,
                maintainAspectRatio: false,
                layout: {
                    padding: { left: 10, right: 10, top: 20, bottom: 20 }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (ctx) => {
                                const d = ctx.raw;
                                // Handle bubble data (has v, time, bv, av)
                                if (d.v !== undefined) {
                                    return `${d.time || ''} | P: ${d.y} | Vol: ${d.v.toLocaleString()}`;
                                }
                                // Handle line chart data (only has x, y)
                                const time = new Date(d.x).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', timeZone: 'Asia/Jakarta' });
                                return `${time} | Harga: ${d.y}`;
                            },
                        },
                    },
                    datalabels: { display: false }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute',
                            stepSize: 30,
                            displayFormats: {
                                minute: 'HH:mm'
                            }
                        },
                        adapters: {
                            date: {
                                zone: 'Asia/Jakarta'
                            }
                        },
                        title: { display: true, text: "Waktu (WIB)" },
                        grid: { display: true, color: 'rgba(241,245,249,1)' }
                    },
                    y: {
                        position: 'left',
                        min: minY - yPadding,
                        max: maxY + yPadding,
                        title: { display: true, text: "Harga" },
                        grid: { display: true, color: 'rgba(241,245,249,1)' }
                    },
                    y1: {
                        position: 'right',
                        title: { display: true, text: "CVD", color: '#fbbf24' },
                        grid: { display: false },
                        ticks: { color: '#fbbf24' }
                    }
                },
            };

            if (footprintChart) footprintChart.destroy();
            footprintChart = new Chart(canvas, {
                data,
                options
            });
        }


        // Tabel time series (opsional â€“ butuh <table id="timeseries-table"> di HTML)
        function renderTimeSeriesTable(snapshot, history) {
            const tbody = document.querySelector("#timeseries-table tbody");
            if (!tbody) return;

            tbody.innerHTML = "";

            if (!history || !history.length) {
                const tr = document.createElement("tr");
                const td = document.createElement("td");
                td.colSpan = 8;
                td.className = "text-center text-muted py-3";
                td.textContent = "Belum ada data history 5 menit.";
                tr.appendChild(td);
                tbody.appendChild(tr);
                return;
            }

            // VWAP sementara: pakai snapshot.vwap kalau ada, kalau tidak pakai close
            const vwap = (typeof snapshot.vwap === "number" && snapshot.vwap > 0)
                ? snapshot.vwap
                : snapshot.close || 0;

            const sorted = [...history].sort((a, b) => {
                if (!a.t || !b.t) return 0;
                return a.t.localeCompare(b.t);
            });

            let prevPrice = null;

            sorted.forEach((h) => {
                const tr = document.createElement("tr");

                const t = h.t || "-";
                const price = h.p || 0;
                const mom = (typeof h.m === "number") ? h.m : 0;
                const absorb = (typeof h.abs === "number") ? h.abs : 0;
                const val = (h.v || 0) * price * 100; // Value (cum) = Vol * Price * 100

                let priceClass = "";
                let deltaText = "-";

                if (prevPrice !== null) {
                    const diff = price - prevPrice;
                    if (diff > 0) {
                        priceClass = "text-success fw-semibold";
                        deltaText = `+${diff}`;
                    } else if (diff < 0) {
                        priceClass = "text-danger fw-semibold";
                        deltaText = `${diff}`;
                    } else {
                        // harga sama dengan bucket sebelumnya â†’ cek VWAP
                        if (vwap && price >= vwap) {
                            priceClass = "text-success fw-semibold";
                        } else {
                            priceClass = "text-danger fw-semibold";
                        }
                        deltaText = "0";
                    }
                }

                const tdDate = document.createElement("td");

                // DATA DATE LOGIC:
                // 1. Use snapshot.date if available.
                // 2. Else, check if it's "Pre-Market" today (< 09:00). If so, data is likely from Yesterday.
                // 3. Otherwise, assume Today.
                let dateObj = new Date();
                if (snapshot.date) {
                    // If provided, assume it's parseable or just use text
                    // But here we want a specific format, so let's stick to text if it's already formatted
                    // Or if it is NOT provided:
                } else {
                    const now = new Date();
                    if (now.getHours() < 9) {
                        // Assume data is from previous day
                        dateObj.setDate(now.getDate() - 1);
                    }
                    // else keep Today
                }

                const dateStr = snapshot.date || dateObj.toLocaleDateString('id-ID', {
                    day: '2-digit', month: '2-digit', year: 'numeric'
                });
                tdDate.textContent = dateStr;

                const tdTime = document.createElement("td");
                tdTime.textContent = t;

                const tdPrice = document.createElement("td");
                tdPrice.textContent = formatNum(price);
                tdPrice.className = "text-end";
                if (priceClass) tdPrice.classList.add(...priceClass.split(" "));

                const tdDelta = document.createElement("td");
                tdDelta.textContent = deltaText;
                tdDelta.className = "text-end";
                if (priceClass) tdDelta.classList.add(...priceClass.split(" "));

                const tdMom = document.createElement("td");
                tdMom.textContent = `${mom.toFixed(2)}%`;
                tdMom.className = "text-end";

                const tdAbs = document.createElement("td");
                tdAbs.textContent = absorb.toLocaleString("id-ID", {
                    minimumFractionDigits: 1,
                    maximumFractionDigits: 1,
                });
                tdAbs.className = "text-end";

                // CVD Cell - get from chart data if available
                const cvdArr = window.cvdDataForTable || [];
                const cvdEntry = cvdArr.find(c => c.x === h.x);
                const cvdVal = cvdEntry ? cvdEntry.y : 0;

                const tdCVD = document.createElement("td");
                tdCVD.textContent = cvdVal.toLocaleString("id-ID");
                tdCVD.className = "text-end";
                tdCVD.style.color = cvdVal >= 0 ? '#22c55e' : '#ef4444';

                const tdVal = document.createElement("td");
                tdVal.textContent = val.toLocaleString("id-ID");
                tdVal.className = "text-end";

                tr.appendChild(tdDate);
                tr.appendChild(tdTime);
                tr.appendChild(tdPrice);
                tr.appendChild(tdDelta);
                tr.appendChild(tdMom);
                tr.appendChild(tdAbs);
                tr.appendChild(tdCVD);
                tr.appendChild(tdVal);

                tbody.appendChild(tr);
                prevPrice = price;
            });
        }



        function pollRepairStatus(kode, dateStr) {
            // Show repair container, hide chart and table
            $("#repair-container").removeClass("d-none");
            $("#repair-title").text(`Update Data ${kode}`);
            $("#chart-container").addClass("d-none");
            $("#table-container").addClass("d-none");

            let simulatedPct = 5;
            let auditFailed = false;
            const reloadAfter = 15000; // Auto-reload after 15 seconds
            const startTime = Date.now();

            // Progress simulation timer (runs regardless of audit-trail status)
            const progressTimer = setInterval(() => {
                const elapsed = Date.now() - startTime;
                // Simulate progress: 5% -> 95% over 15 seconds
                simulatedPct = Math.min(95, 5 + Math.floor((elapsed / reloadAfter) * 90));
                $("#repair-progress-bar").css("width", `${simulatedPct}%`);
                $("#repair-pct-text").text(`${simulatedPct}%`);

                if (elapsed >= reloadAfter) {
                    clearInterval(progressTimer);
                    clearInterval(auditTimer);
                    $("#repair-status-text").text("Update selesai! Memuat ulang...");
                    $("#repair-progress-bar").css("width", "100%").removeClass("progress-bar-animated");
                    $("#repair-pct-text").text("100%");
                    setTimeout(() => location.reload(), 1000);
                }
            }, 1000);

            // Audit-trail polling (optional - updates status text if available)
            const auditTimer = setInterval(() => {
                if (auditFailed) return; // Skip if already failed

                $.getJSON(`${API_BASE}/audit-trail?symbol=${kode}&limit=5`, function (resp) {
                    if (resp.ok && resp.entries && resp.entries.length > 0) {
                        const latest = resp.entries.find(e => e.action === "REPAIR_FOOTPRINT" && e.data_date === dateStr);
                        if (latest) {
                            if (latest.status === "COMPLETED" || latest.status === "SUCCESS") {
                                clearInterval(progressTimer);
                                clearInterval(auditTimer);
                                $("#repair-status-text").text("Perbaikan selesai! Memuat ulang data...");
                                $("#repair-progress-bar").css("width", "100%").removeClass("progress-bar-animated");
                                $("#repair-pct-text").text("100%");
                                setTimeout(() => location.reload(), 1500);
                            } else if (latest.status === "PROCESSING") {
                                $("#repair-status-text").text(latest.detail || "Sedang memproses data...");
                            }
                        }
                    }
                }).fail(function () {
                    auditFailed = true;
                    $("#repair-status-text").text("Mengupdate data di background...");
                });
            }, 3000);
        }

        function loadSnapshotAndHistory() {
            const kode = getKodeFromURL();
            const mode = getModeFromURL();

            $('#fundflow-link').attr('href', `broker-summary.html?kode=${kode}`);
            $('#audit-link').attr('href', `broker-summary.html?kode=${kode}#audit`);

            // 1. Load Snapshot (Lightweight Header)
            $.getJSON(`${API_BASE}/symbol?kode=${encodeURIComponent(kode)}&mode=${encodeURIComponent(mode)}`, function (resp) {
                const snapshot = resp.snapshot || {};
                const state = resp.state || null;
                const isRepairing = resp.is_repairing === true;
                const isFallback = resp.is_fallback === true;

                // Toggle Fallback Alert
                if (isFallback) {
                    $("#fallback-alert").removeClass("d-none");
                } else {
                    $("#fallback-alert").addClass("d-none");
                }

                // Store repair flag for later check (after data is loaded, we can verify if data is sufficient)
                const repairFlagForLater = isRepairing;

                // Enrich snapshot
                let haka = snapshot.haka_pct;
                if ((haka === undefined || haka === null) && typeof snapshot.money_flow === "number") {
                    haka = Math.round((snapshot.money_flow + 1) * 50);
                }
                if (haka === undefined || haka === null || Number.isNaN(haka)) haka = 50;

                let fluk = snapshot.fluktuasi;
                if ((fluk === undefined || fluk === null) && typeof snapshot.momentum === "number") {
                    fluk = Number(snapshot.momentum.toFixed(2));
                }
                if (fluk === undefined || fluk === null || Number.isNaN(fluk)) fluk = 0;

                const enrichedSnapshot = { ...snapshot, haka_pct: haka, fluktuasi: fluk };

                // Render Header immediately
                renderSnapshot(kode, mode, enrichedSnapshot, state);

                // 2. Load Full History (Heavier Data)
                const dateStr = snapshot.date || new Date().toISOString().split("T")[0];
                $.getJSON(`${API_BASE}/footprint-raw-hist?kode=${kode}&date=${dateStr}`, function (histResp) {
                    const fullHistory = histResp.buckets || [];
                    const fullCandles = histResp.candles || [];
                    const tableData = histResp.tableData || fullHistory;


                    // ========================================
                    // THOUGHT PROCESS LOGGING (Browser Console)
                    // Only shows when ?debug=true is in the URL
                    // ========================================
                    const urlParams = new URLSearchParams(window.location.search);
                    const isDebugMode = urlParams.get('debug') === 'true';

                    if (isDebugMode) {
                        const now = new Date();
                        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                        const dayOfWeek = now.getDay();
                        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                        const todayStr = now.toISOString().split("T")[0];
                        const isToday = dateStr === todayStr;
                        const nowUTC = now.toISOString().slice(11, 16);
                        const nowWIBHour = now.getHours();
                        const nowWIBMin = now.getMinutes();
                        const nowWIB = `${String(nowWIBHour).padStart(2, '0')}:${String(nowWIBMin).padStart(2, '0')}`;
                        const marketOpenHour = 9;
                        const marketCloseHour = 16;
                        const isMarketOpen = !isWeekend && nowWIBHour >= marketOpenHour && nowWIBHour < marketCloseHour;

                        // Calculate expected candles
                        let expectedCandleCount = 0;
                        let expectedDescription = '';
                        if (isToday && !isWeekend && nowWIBHour >= marketOpenHour) {
                            const elapsedMins = (Math.min(nowWIBHour, marketCloseHour) - marketOpenHour) * 60 + (nowWIBHour < marketCloseHour ? nowWIBMin : 0);
                            expectedCandleCount = Math.floor(elapsedMins / 5);
                            expectedDescription = `~${expectedCandleCount} candles (09:00-${nowWIB} WIB = ${elapsedMins} mins Ã· 5)`;
                        } else if (!isToday) {
                            expectedCandleCount = 84;
                            expectedDescription = '~84 candles (09:00-16:00 WIB = 420 mins Ã· 5)';
                        } else {
                            expectedDescription = isWeekend ? 'Weekend - no trading' : 'Market not open yet';
                        }

                        console.log(`\n%c========== [THOUGHT PROCESS] ${kode} @ ${dateStr} ==========`, 'color: #00bcd4; font-weight: bold');
                        console.log(`%c[ðŸ• NOW]%c Today is ${todayStr} (${dayNames[dayOfWeek]})`, 'color: #8bc34a', 'color: inherit');
                        console.log(`%c[ðŸ• NOW]%c Current Time: ${nowWIB} WIB (${nowUTC} UTC)`, 'color: #8bc34a', 'color: inherit');
                        console.log(`%c[ðŸ“… CONTEXT]%c Today is ${isWeekend ? 'WEEKEND ðŸ–ï¸' : 'WEEKDAY ðŸ’¼'}${isMarketOpen ? ' - MARKET OPEN ðŸ“ˆ' : ''}`, 'color: #ff9800', 'color: inherit');
                        console.log(`%c[ðŸ“Š REQUEST]%c User requested data for: ${dateStr} (${isToday ? 'TODAY' : 'PAST TRADING DAY'})`, 'color: #2196f3', 'color: inherit');
                        console.log(`%c[ðŸ“ API FETCH]%c Received ${fullCandles.length} candles, ${tableData.length} table rows, ${fullHistory.length} bubbles`, 'color: #9c27b0', 'color: inherit');

                        // Last candle analysis
                        if (fullCandles.length > 0) {
                            const lastCandle = fullCandles[fullCandles.length - 1];
                            const lastCandleDate = new Date(lastCandle.x);
                            const lastH = lastCandleDate.getHours();
                            const lastM = lastCandleDate.getMinutes();
                            const lastUTC = lastCandleDate.toISOString().slice(11, 16);
                            const lastWIB = `${String(lastH).padStart(2, '0')}:${String(lastM).padStart(2, '0')}`;

                            console.log(`%c[ðŸ“ˆ CHART]%c Last candle at ${lastWIB} WIB (${lastUTC} UTC)`, 'color: #e91e63', 'color: inherit');
                            if (!isToday) {
                                const reachesClose = lastH >= 15 && lastM >= 50;
                                console.log(`%c[ðŸ“ˆ CHART]%c For past trading day, market close is 15:50 WIB. Last candle ${reachesClose ? 'REACHES âœ…' : 'DOES NOT REACH âŒ'} market close`, 'color: #e91e63', reachesClose ? 'color: green' : 'color: red');
                            } else {
                                console.log(`%c[ðŸ“ˆ CHART]%c For today, expecting data up to ~${nowWIB} WIB (${nowUTC} UTC)`, 'color: #e91e63', 'color: inherit');
                            }
                        }

                        // Table/Candle quality assessment
                        const actualCount = tableData.length;
                        const isSufficient = expectedCandleCount > 0
                            ? actualCount >= (expectedCandleCount * 0.5)
                            : actualCount >= 3;

                        console.log(`%c[ðŸ“Š TABLE]%c Expected: ${expectedDescription}`, 'color: #795548', 'color: inherit');
                        console.log(`%c[ðŸ“Š TABLE]%c Actual: ${actualCount} rows`, 'color: #795548', 'color: inherit');
                        console.log(`%c[ðŸ“Š TABLE]%c Status: ${isSufficient ? 'SUFFICIENT âœ…' : 'SPARSE âš ï¸'} (threshold: ${expectedCandleCount > 0 ? Math.floor(expectedCandleCount * 0.5) : 3})`, 'color: #795548', isSufficient ? 'color: green' : 'color: orange');

                        // Fallback & Repair status from API
                        const isFallback = histResp.is_fallback === true;
                        const isRepairing = histResp.is_repairing === true;
                        console.log(`%c[ðŸ”„ FALLBACK]%c Using fallback data: ${isFallback ? 'YES âœ…' : 'NO'}`, 'color: #ff5722', isFallback ? 'color: green' : 'color: inherit');
                        console.log(`%c[ðŸ”§ REPAIR]%c Background repair in progress: ${isRepairing ? 'YES ðŸ”§' : 'NO'}`, 'color: #607d8b', isRepairing ? 'color: orange' : 'color: inherit');
                        console.log(`%c========== [END THOUGHT PROCESS] ==========\n`, 'color: #00bcd4; font-weight: bold');
                    }

                    // Update snapshot with full data for the renderers
                    enrichedSnapshot.candles = fullCandles;

                    // Smart repair warning: only show if repair flag is true AND data is insufficient
                    const dataRowCount = tableData.length || fullHistory.length;
                    const isSufficientData = dataRowCount >= 42; // Minimum threshold for full day (50% of 84)

                    if (repairFlagForLater && !isSufficientData) {
                        $("#fallback-alert").removeClass("d-none")
                            .html('<i class="fa-solid fa-sync-alt text-warning me-2 fa-spin"></i><span class="text-dark">Repair data sedang berjalan di background. Chart mungkin belum lengkap.</span>');
                    }

                    renderFootprintTrailFromHistory(kode, enrichedSnapshot, fullHistory, tableData);
                    renderTimeSeriesTable(enrichedSnapshot, tableData);
                }).fail(function () {
                    console.warn("Full history fetch failed, using fallback from /symbol");
                    renderFootprintTrailFromHistory(kode, enrichedSnapshot, snapshot.history || [], snapshot.history || []);
                    renderTimeSeriesTable(enrichedSnapshot, snapshot.history || []);
                });

            }).fail(function (xhr) {
                console.error("Failed load /symbol:", xhr.status, xhr.responseText);
                renderFootprintTrailFromHistory(getKodeFromURL(), {}, [], []);
                renderTimeSeriesTable({}, []);
            });
        }

        $(function () {
            loadSnapshotAndHistory();
        });
        Chart.register(ChartDataLabels);


    </script>

    <div id="search-panel">
        <div class="mb-4">
            <input type="text" id="search-input" class="search-input" placeholder="Masukkan Kode (e.g. BBRI)"
                autocomplete="off">
        </div>

        <div>
            <p class="small opacity-75 mb-2 fw-bold">RIWAYAT PENCARIAN</p>
            <div id="search-history-list">
                <!-- Populated by JS -->
            </div>
        </div>
    </div>
</body>

</html>